import{dirname as Se}from"path";import{tmpdir as me}from"os";import{mkdtemp as de,rm as ue}from"fs/promises";import{basename as fe,join as I}from"path";var y={name:"setup-pesde",version:"0.1.0",description:"",main:"dist/index.js",type:"module",scripts:{prettier:"node --experimental-strip-types node_modules/prettier/bin/prettier.cjs",build:"tsup",dev:"pnpm build && NODE_LOG=debug GITHUB_TOKEN=$(gh auth token) node dist/",test:'echo "Error: no test specified" && exit 1'},keywords:[],author:"",license:"GPL-3.0-only",engines:{pnpm:"^10.13.1",node:"^16.20.2"},dependencies:{"@actions/core":"^1.11.1","@actions/exec":"^1.1.1","@actions/github":"^6.0.1","@actions/io":"^1.1.3","@actions/tool-cache":"^2.0.2","@octokit/openapi-types":"^20.0.0",decompress:"npm:@xhmikosr/decompress@^10.2.0","decompress-tar":"npm:@xhmikosr/decompress-tar@^8.1.0","decompress-tarbz2":"npm:@xhmikosr/decompress-tarbz2@^8.1.0","decompress-targz":"npm:@xhmikosr/decompress-targz@^8.1.0","decompress-tarxz":"npm:@felipecrs/decompress-tarxz@^5.0.4","decompress-unzip":"npm:@xhmikosr/decompress-unzip@^7.1.0","is-interactive":"^2.0.0",ora:"^9.0.0",winston:"^3.18.3","winston-transport":"^4.9.0"},devDependencies:{"@octokit/types":"^15.0.1","@types/decompress":"^4.2.7","@types/node":"^24.9.1",eslint:"^9.38.0","eslint-plugin-prettier":"^5.5.4",prettier:"^3.6.2",tsup:"^8.5.0",typescript:"^5.9.3"}};import{appendFileSync as oe,existsSync as se}from"fs";import re from"winston-transport";import te from"winston";var T=class extends re{console=new te.transports.Console;spinner=null;constructor(e){super(e)}setSpinner(e){return this.spinner=e,e}log(e,s){setImmediate(()=>this.emit("logged",e));let r=this.console.log?.bind(this.console)??console.log;if(this.spinner&&this.spinner.isSpinning){let o=this.spinner.text;this.spinner.stop(),r(e,s),this.spinner.text=o,this.spinner.start()}else r(e,s)}};import{isDebug as ne}from"@actions/core";import l from"winston";var R=()=>process.env.DEV_DEBUG||process.env.NODE_LOG==="debug"||ne(),L=l.format.combine(l.format.simple(),l.format.errors(),l.format.splat(),l.format(t=>(t.scope&&(t.message=`\x1B[2m${t.scope}\x1B[0m: ${t.message}`,delete t.scope),t))()),m=l.createLogger({level:R()?"debug":"info",format:R()&&process.env.NODE_ENV==="production"?l.format.json():l.format.combine(L,l.format.cli()),transports:[new T,(()=>{let t=`${y.name}.log`,e=se(t)?`
`:"",s=new Date;return oe(t,`${e}// ${y.name} started at ${s.toLocaleDateString()} at ${s.toLocaleTimeString()}
`),new l.transports.File({filename:t,format:l.format.combine(L,l.format.uncolorize()),level:"debug"})})()]});import{getInput as ie}from"@actions/core";import{getOctokit as ae}from"@actions/github";var u=m.child({scope:"github"});function ce(t){if(!t)return"<none>";let e=t.substring(0,5);return t.replace(new RegExp(t,"g"),`${e}***`)}var _=ie("token")||process.env.GITHUB_TOKEN;u.info(`Initalized GitHub client with token: ${ce(_)}`);function F(t){return async(e,s)=>{let r=String(e),o=s?.method||"GET";u[t](`\u2192 ${o} ${r}`);let n=performance.now(),a=await fetch(e,s),f=(performance.now()-n).toFixed(2);return u[t](`\u2190 ${a.status} ${o} ${r} (${f}\u03BCs)`),a}}u=u.child({scope:"github.octokit"});var A=ae(_,{request:{fetch:R()?F("debug"):fetch},log:{debug:u.debug,info:u.info,warn:u.warn,error:u.error}});var G={windows:["windows"],macos:["macos","darwin","apple"],linux:["linux","ubuntu","debian","fedora"]},N={windows:["win","win32","win64"],macos:["mac","osx"],linux:[]};function j(){if(process.platform==="win32"||process.platform==="cygwin")return"windows";if(process.platform==="darwin")return"macos";if(process.platform==="linux")return"linux";throw new Error(`Unsupported OS: ${process.platform}`)}function P(t){let e=t.toLowerCase();for(let r of Object.keys(G))for(let o of G[r])if(e.includes(o))return r;let s=e.split(/[^a-z0-9]+/);for(let r of Object.keys(N))for(let o of N[r])if(s.includes(o)||e.includes(o))return r}var C={arm64:["aarch64","arm64","armv9"],x64:["x86-64","x86_64","amd64","win64","win-x64"],arm32:["arm32","armv7"],x86:["i686","i386","win32","win-x86"]},M={arm64:[],x64:["x64","win"],arm32:["arm"],x86:["x86"]};function q(){if(process.arch==="arm64"||process.arch=="x64")return process.arch;if(process.arch==="arm")return"arm32";if(process.arch==="ia32")return"x86";throw new Error(`Unsupported architecture: ${process.arch}`)}function H(t){let e=t.toLowerCase();for(let r of Object.keys(C))for(let o of C[r])if(e.includes(o))return r;let s=e.split(/[^a-z0-9]+/);for(let r of Object.keys(M))for(let o of M[r])if(s.includes(o))return r;if(e.includes("universal")&&P(t)==="macos")return"x64"}var x=class t{static logger=m.child({scope:"descriptor"});os;arch;constructor(e,s){if(s!=null)this.os=e,this.arch=s;else{let r=P(e),o=H(e);if(!r||!o)throw t.logger.warn(`Unable to detect architecture or OS from '${e}' confidently, skipping`),new Error("Malformed input string");this.os=r,this.arch=o}return this}static currentPlatform(){return new t(j(),q())}toString(){return`${this.os}-${this.arch}`}equals(e){return this.os==e.os&&this.arch==e.arch}},k=class{inner;asset;constructor(e){return this.inner=new x(e.name),this.asset=e,this}get os(){return this.inner.os}get arch(){return this.inner.arch}toString(){return this.inner.toString()}equals(e){return this.os==e.os&&this.arch==e.arch}};import{mkdir as pe}from"fs/promises";import le from"decompress";Array.prototype.filterMap=function(t){return this.flatMap(e=>{let s=t(e);return s!=null?[s]:[]})};function E(t,...e){try{return t(e)}catch{return null}}async function V(t,e,s){let r=["decompress-tar","decompress-targz","decompress-tarbz2","decompress-tarxz","decompress-unzip"];return le(t,e,{...s,plugins:await Promise.all(r.map(async o=>await import(o).then(n=>n.default())))})}function h(t,e=2){if(t<0)throw new Error("Bytes must be non-negative");if(t===0)return"0 B";let s=["B","KB","MB","GB","TB","PB"],r=t,o=0;for(;r>=1024&&o<s.length-1;)r/=1024,o++;let n=s[o];if(!n)throw new Error("Bytes value too large");return`${parseFloat(r.toFixed(e))} ${n}`}async function W(t){try{await pe(t,{recursive:!0})}catch(e){throw console.error(`Failed to ensure directory existence: ${e}`),e}}var v=class{githubRepo;versionOrPredicate="latest";logger=m.child({scope:"toolmanager"});constructor(e,s){this.githubRepo={owner:e,repo:s}}version(e){return this.versionOrPredicate=e,this}async install(e,s=import.meta.dirname,r=this.githubRepo.repo){let o=this.logger.child({scope:"toolmanager.install"}),n=await this.findCompatibleAsset();if(n==null)throw o.error(`No compatible artifact found for current system for ${this.githubRepo.owner}/${this.githubRepo.repo}`),new Error("No artifact found");let{size:a,name:f}=n.asset;o.info(`Attempting to download '${f}' (${h(a)})`);let p=await de(I(me(),`${y.name}-`));try{let g=I(p,n.asset.name);return await e(n.asset.browser_download_url,g,a),await V(g,s,{filter:i=>fe(i.path)==r,strip:5}).then(i=>i.length==0?Promise.reject(`Could not find binary '${r} in downloaded artifact'`):Promise.resolve(i)).then(()=>I(s,r)).catch(i=>void o.error(i))}finally{await ue(p,{recursive:!0})}}async findCompatibleAsset(){let e=this.logger.child({scope:"toolmanager.findCompatibleAsset"}),{version:s,assets:r}=await this.resolveVersion();e.info(`Received ${r.length} assets for ${this.githubRepo.repo}@${s}`);let o=r.filterMap(a=>E(()=>new k(a))),n=x.currentPlatform();for(let a of o){if(a.equals(n))return e.info(`Found matching artifact for ${n}: ${a.asset.name}`),a;e.debug(`${a.asset.name} \u2192  asset: ${a}, system: ${n}`)}return null}async resolveVersion(){let e=this.logger.child({scope:"toolmanager.resolveVersion"}),s=({data:r})=>({version:r.tag_name,assets:r.assets});if(typeof this.versionOrPredicate=="string")return this.versionOrPredicate=="latest"?(e.warn("No explicit version requested, defaulting to latest"),await A.rest.repos.getLatestRelease({...this.githubRepo}).then(s)):(e.info("Attempting to fetch version %s",this.versionOrPredicate),await A.rest.repos.getReleaseByTag({...this.githubRepo,tag:this.versionOrPredicate}).then(s));if(typeof this.versionOrPredicate=="function"){e.debug("Version predicate function provided, will attempt to filter");let{data:r}=await A.rest.repos.listReleases({...this.githubRepo});for(let o of r)if(this.versionOrPredicate(o.tag_name))return s({data:o})}return Promise.reject("unreachable: invalid versionOrPredicate type")}};import*as B from"fs";import{pipeline as ge}from"stream/promises";import{Readable as he}from"stream";import we from"path";import be from"is-interactive";import ye from"ora";var d=m.child({scope:"download"}),U={TrackedDownload:xe,Actions:async(t,e,s)=>{try{let{downloadTool:r}=await import("@actions/tool-cache");await r(t,e)}catch{throw new Error("Download failed (outside actions environment?): {$err}")}}};async function xe(t,e,s){let r=ve(),o=F("info"),n=null,a=Date.now(),f=!1,p=async i=>{f||(f=!0,n&&n.abort(),r.fail(i),E(async()=>{await B.promises.unlink(e),d.debug("Cleaning up partial download file")}))},g=async i=>{await p(`Download interrupted by ${i}`),process.exit(1)};process.on("SIGINT",()=>g("SIGINT")),process.on("SIGTERM",()=>g("SIGTERM")),d.debug(`Saving to: ${e}`);try{n=new AbortController;let i=await o(t,{signal:n.signal});if(!i.ok)throw r.fail(`Download failed: ${i.status} ${i.statusText}`),new Error("Download failed");let c=s??parseInt(i.headers.get("content-length")||"0",10);if(c==0?(d.warn("Unknown file size, progress cannot be displayed"),r.setText("Downloading...")):d.info(`File size: ${h(c)}`),!i.body)throw d.error("No response body returned!"),new Error("Download failed");W(we.dirname(e));let w=he.fromWeb(i.body),$=B.createWriteStream(e),D=Date.now(),O=0;w.on("data",Z=>{O+=Z.length;let z=Date.now();c&&(z-D>100||O===c)&&(D=z,r.update(O,c,z-a))}),await ge(w,$);let b=((Date.now()-a)/1e3).toFixed(2),Y=c?h(c/parseFloat(b))+"/s":"N/A";r.success(`Download completed in ${b}s (avg: ${Y})`),d.info(`Download completed successfully in ${b}s`)}catch(i){let c=i;r.fail(`Download failed: ${c.message}`),c.name==="AbortError"&&await p("Download aborted"),await p(c.message)}finally{process.removeAllListeners("SIGINT"),process.removeAllListeners("SIGTERM")}}function ve(t=30){let e=be(),r=d.transports[0].setSpinner(ye({color:"cyan",prefixText:"info:    ",isEnabled:e,spinner:{frames:[""]}})).start(),o=0;return{success:n=>{r.stop(),d.info(n)},fail:n=>{r.stop(),d.error(n)},setText:n=>r.text=n,update:(n,a,f)=>{let p=Math.floor(n/a*100),g=h(n),i=h(a),c=(f/1e3).toFixed(1),w=h(n/(parseFloat(c)||1))+"/s";if(!e)p>=o+25&&p<100&&(d.info(`Progress: ${p}% (${g}/${i}, ${w})`),o=p);else{let $=Math.floor(p/100*t),D=t-$,b=`[${"\u2588".repeat($)+"\u2591".repeat(D)}]`;r.text=`${b} ${p}% | ${g}/${i} | ${w} | ${c}s`}}}}import{cacheDir as $e,find as De}from"@actions/tool-cache";import*as S from"@actions/core";var J={pesde:{owner:"pesde-pkg",repo:"pesde"},lune:{owner:"lune-org",repo:"lune"}},Q=m.child({scope:"actions"});Q.exitOnError=!0;async function X(t,e){let s=Q.child({scope:"actions.setupTool"}),r=De(t.repo,e);r==""&&(r=await new v(t.owner,t.repo).version(e).install(U.Actions).then(o=>o?Promise.resolve(o):Promise.reject("Download failed.")).catch(o=>void s.error(o)).then(o=>$e(Se(o),t.repo,e))),S.addPath(r)}var K=S.getInput("lune-version");K!==""&&await X(J.lune,K);await X(J.pesde,S.getInput("version"));
